# Лабораторные работы по дисциплине "Методы трансляции"

Нужно было разработать простенький транслятор языка C++ в соответствии с вариантом. Вся работа разделена на 4 лабы и РГЗ (расчётно-графическое задание).

**Вариант 6.** Подмножество языка С++ для нашего варианта включает:
- данные типа int, float, char;
- инструкции описания переменных;
- операторы присваивания в любой последовательности;
- операции +, –, *, =, ==, !=, <, > .

Суть транслятора в конечном счёте сводится к преобразованию невероятно урезанного кода на C++ в код на ассемблере. Помимо методических указаний, мне очень помог вот этот [реусурс](https://pages.cs.wisc.edu/~fischer/cs536.s08/course.hold/html/NOTES/)

По итогу получлось что-то страшное -- первая программа на плюсах в отрыве от си.

## Компиляция, запуск и отладка

Для компиляции необходимы `g++` и `make`, а для отладки -- `nasm` и `gdb`.

Чтобы скомпилировать программу, перейдите в корневую папку и напишите:

```bash
$ make
```

Скомпилированная программа окажется в папке `bin`. Чтобы запустить её, напишите:

```bash
$ ./bin/translator
```

Транслятор преобразует файл `test.cpp` в ассемблерный листинг и поместит его в файл `hello.asm`.

Программа собирается с отладочной информацией. Чтобы отладиьт программу, запустите скрипт `debug.sh`:

```bash
$ ./debug.sh
```

## Выполнение лаб

Файлов с кодом задействовано чуть больше, чем упоминается ниже. О назначении остальных можно догадаться по названию или тому, как они используются в программе.

### Л1. Проектирование и реализация таблиц, используемых в трансляторе

Файлы [`table.cpp`](src/table.cpp) и [`table.hpp`](src/table.hpp).

Сдеано два типа таблиц:

- **Статическая.** Элементы таблицы формируются единожды при создании таблицы и не могут быть изменены.
- **Динамическая.** Элементы засовываются потом, а находятся по хэшу от ключей. Получилась хэш-таблица (словарь).

> У динамической таблицы есть вектор со всеми ключами. Он возник спонтанно во время написания четвёртой лабы. Вообще, нужно было как-то итерироваться по списку, но времени было в обрез :/

### Л2. Разработка и реализация блока лексического анализа

Файлы [`scanner.cpp`](src/scanner.cpp) и [`scanner.hpp`](src/scanner.hpp).

Преобразуем текст программы на C++ в токены. Каждый токен это два числа -- номер таблицы и как искать этот элемент в таблице. Поиск в статических таблицах осуществляются по порядковому номеру (нумерация с нуля), а в динамических -- по хешу.

В нашем случае лексчиеский анализатор (сканнер) это конечный автомат состояний. Мы проходим по символам, запихивая в очередь (или нет, если символы пробельные), и переходя между состояними. Когда мы ловим "терминальный" для текущего состояний символ, мы на основе текущего состояния и той самой очереди формируем токен. И запииваем его к другим токенам.

> За State-паттерн большое спасибо этой [книге](http://gameprogrammingpatterns.com/state.html).

### Л3. Разработка и реализация блока синтаксического анализа

Файлы [`parser.cpp`](src/parser.cpp) и [`parser.hpp`](src/parser.hpp).

Преобразуем токены в [обратную польскую запись](https://en.wikipedia.org/wiki/Reverse_Polish_notation). Поездатое базовое объяснение польской записи есть на [хабре](https://habr.com/ru/post/100869/).

Суть в том, что нам нужно перебрать все токены по некоему шаблону. Если бы не т.н. Parse Table и LL-грамматика, это превратилось бы в невероятную дичь.

Как составить LL-грамматику, я не знаю. Мы взяли чужую работу (которую тоже откуда-то скатали) и переделал под свой вариант, исправив некоторые ошибки. Дальше нарисовал красивый [граф](reference/table.png) и [табличку](reference/ParseTable.csv).

В самом парсере мы итерируемся по токенам, обрабатывая их в соответствии с таблицей. Некоторые нужные нам токены (операции/константы/переменные/скобки) на "польский стек" (который на самом деле `vector`).

Вся теория написана в методических указаниях по предмету.

### Л4. Разработка и реализация блока генерации кода

Файлы [`code_generator.cpp`](src/code_generator.cpp) и [`code_generator.hpp`](src/code_generator.hpp).

Преобразуем польскую запись в четвёрки, которые затем преобразуем в ассемблерный код.

> **Четвёрка** представляет из себя "кортеж" из двух операндов, производимой над ними операции и перемнной для записи результата.

Четвёрки у нас оптимизированы очень слабо -- они создают больше побочных переменных, чем хотелось бы. А ещё операции сравнения (==, !=, <, >) у нас работают только на `float`. Если расширять программу, то с `char` могут возникнуть проблемы. В ассемблерном листинге мы работаем с ним почти как с `int`.

Блок генерации кода реализован так себе. Нужно было дробить ассемблерный код посильнее, чтобы можно было генерировать по шаблонам, зависящих от типа.

### РГЗ. Разработка и реализация блока генерации кода

В качестве расчётно-графического задания нам нужно было обработать ошибки, связанные с недопустимыми преобразованиями типов. Всё, что мы сделали, это убрали возможность приравнять целочисленной переменной (int/char) дробное число (float).

Тип float является привалирующим. Это значит, что если в правой части есть хотя бы одна переменная/константа с плавающей запятой, то всё выражение в итоге имеет тип `float`.

Части кода, отвечающие за эту работу, можно посмотреть в [`rgz.cpp`](rgz.cpp).